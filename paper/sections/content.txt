% An easy first example would be FFI between Rust and C++, both statically typed languages which use llvm for the IR and could be considered a comfortable middle ground between low-and-high level providing some abstractions but generally still utilized for high performance applications. Both of these languages have a C-ABI and for most basic types including booleans, numerics, strings, and structs either have a convenience method ensuring the correct memory layout or trivially have the correct layout. This is the case for most statically typed languages, where primitives usually are either aliases for their C counterparts or have some means of being passed with the correct memory layout. 

If this is not possible we encounter boxing. Boxing refers to the idea of wrapping a value of a certain type within some \texttt{Box} type which allows for uniform passage across the FFI boundary; generally as a heap allocated pointer. The most simple example of boxing would be casting a heap allocated data structure to a \texttt{void*}. The inverse being unboxing which is the process of extracting a datatype in its original intended form. Boxing is a common feature of managed languages, that is languages which execute via some type of runtime environment such as a virtual machine and implement features such as polymorphism, garbage collection, or other mechanisms where some type of wrapping is required to manage a type. Broadly speaking Boxing is generally either implemented through either vtables (e.g. Rust dyn traits, C++ classes, Java classes, Go interfaces), or dictionary passing (e.g. Swift, Haskell, OCaml). 

Across language boundaries polymorphism and generic code start to encounter some issues. As mentioned previously a key problem is that languages generally have unique implementations of polymorphism which usually have no easy mapping to the C ABI. First to define what we mean here when talking about polymorphism it makes sense to distinguish between different kinds. When talking about parametric polymorphism we are referring to a method or type which can be written takes a type or multiples types as a parameter, a basic example utilizing polymorphic lambda calculus can be expressed as:

\[
\Gamma \vdash \Lambda \alpha .\lambda x^{a} .\lambda y^{a} .x+y:\forall \alpha .\alpha \rightarrow \alpha \rightarrow \alpha
\]

Here we are expressing the \textit{type} of a polymorphic addition function addition function - denoted by $\Lambda$ - that takes to inputs $x$ and $y$ of some polymorphic type $a$ and yields a summation of type $a$.  The most common way languages choose to implement parametric polymorphism is through monomorphism, in other words they create instances based on valid substitutable concrete types and error if an invalid type is used. This is also commonly called static polymorphism as all types are statically resolved at compile time. 

The issue with this implementation of parametric polymorphism is that it makes dynamic linking virtually impossible. That is to say, generic library methods cannot be dynamically linked to as its an inherent feature of most monomorphizing systems that the compiler creates concrete instances dependent on call sites, thus if a library is compiled without an exposed generic ever being called then this generic is simply never compiled into any concrete instance. Now this can be obviously mitigated through various means, a library author could provide some interface to the generic or explicitly instantiate them though in both cases the generic is not natively used as if it where a direct part of your own source code. The same issue then naturally extends to language interoperability, languages which implement generics purely through monomorphizing have virtually no way of exposing a truly generic function across an FFI boundary in dynmaic libraries.

Despite this limitation due to the nature of how monomorphism works there are still various approaches one can take to get around this, some of which I will enumerate now. Most statically typed languages implemented monomorphism at the semantic analysis stage of compilation. In the case of C++ for example translation units (processed source code files) are examined and from this a list of required instantiations is created, from this all required intantions are preformed which creates instantiation units which simply refers to translation units which do not have an uninstantiated templates and no template definitions. There are two types of generic instantiations in C++ \textit{implicit} and \textit{explicit}. Implicit instantiations as the name implies generate concrete instances through the use of a generic with a particular subsitutable type, explicit instantiations on the other hand are used to solely generate concrete instances (which can then be used). Both implicit and explicit instantiations on the symbol level are mangled using a particular scheme and in the case of C++ generics are marked with \texttt{comdat} and \texttt{linkonce\_odr} which means that duplicate instantiated templates only have one concrete instance linked in the final executable to avoid code duplication.

% One approach to then enable interop between languages which monomorphize in a C++-like fashion would be as follows. 
% \begin{enumerate}
%     \item Language $L_1$ emits mangled function signatures with relocations from its compiler
%     \item A bridging utility parses the mangled symbols and generates corresponding explicit instantations in the source code of the target language $L_2$ 
%     \item These generated explicit instantations are used to trigger instantations for the desired methods called in the source code of $L_1$ using its compiler
%     \item Finally the linker resolves the relocations generated by the mangled symbols in $L_1$ and corresponds them to the generated instantations in $L_2$  
% \end{enumerate} 






% Of note there are exceptions to this handling of generics. It should first of all be stated that if you want to expose a generic function in a dynamic library without monomorphizing you inherently cannot avoid some type of runtime type information (RTTI). In other words for a dynamically linked generic method to work the compiler must implement a system to create concrete execution paths at runtime for valid types and otherwise must error. Abstractly RTTI is used to implement a form of dynamic dispatch since everything operates at runtime without the use of traditional dynamic dispatch through subtyping polymorphism, in other words polymorphism through inheritance.  

% To my knowledge currently Swift is the only language which is able to pass at least primtives by value as stack allocated data; along with their type metadata; to dynamically linked generics. Once we get to more complex datatypes Swift - like most other languages - starts to box types and passes pointers to heap allocated objects and depending on the language either as just a point or with additional metadata. In both the boxed and unboxed state Swift utilizes the witness table and the value witness table of a specific type to discern both information regarding its defined methods and memory layout as a means to implement the concrete control flow of the generic function in the dynamic lib analgous to how C++'s VTable mechanism works. 

Most other languages; for those who have it implemented; are generally reliant on subtyping polymorphism when wanting to expose polymorphic methods in a shared library. Implementations of subtyping polymorphism generally follow similar patterns of some type of heap allocation boxing mechanism and then passing the pointer data to the desired method. When speaking about language interoperability this naturally would then require the aforementioned unboxing implementation in the target language to derive/give access to the corresponding types. As one might expect this naturally leads to some overhead as opposed to values being explicitly passed, though the degree of overhead here generally correlates with the complexity of the unboxing interface. In the case of Rust for example where the underlying memory model is simply a Raw pointer to the actual data (without any metadata) there only needs to exist a minimal unboxing interface to allow seamless access to this underlying data in another languages such as C++, though even Rust it seems - currently at least - does not support bidirectional subtyping polymorphism with its trait object implementation utilizing the cxx library. 