\section{Background}\label{s:background}


% \TODO{
% This section is optional. If needed, it provides the necessary context to help the reader understand the remainder of the thesis.
% }

To further gain insights into this world of interoperability I thought it best to continue on with the idea I had of rewriting a component in different languages and then applying some system of interoperability. Decomposing this idea into concrete steps we can develop a rough design of how this study will be conducted.
\begin{enumerate}
    \item Literature review \& Background
    \begin{enumerate}
        \item Review current landscape of language interoperability
        \item Choose suitable libraries to explore our specific use case
        \item Review the intersection of interoperability and program execution methods
    \end{enumerate}
    \item Implementation
    \begin{enumerate}
        \item Profile the Julia application to extract the most performance intensive piece of code
        \item Rewrite this piece of code in different languages, preferably ones which have very different execution models
        \item Write some type of glue layers utilizing the chosen libraries to enable this interoperability
    \end{enumerate}
    \item Analysis \& Development
    \begin{enumerate}
        \item Understand how the type systems of these different languages interact, especially considering types beyond primitives
        \item Profile the programs for all given languages to understand the performance impacts
        \begin{enumerate}
            \item Understand the underlying nature of the performance impacts and how they relate to differences in execution models
        \end{enumerate}
        \item Understand how interop libraries are designed and enable communication between languages
        \begin{enumerate}
            \item Attempt to develop certain solutions for any limitations encountered
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

Literature review and Background

Foreign Function Interface (FFI)

FFI is a generic term which describes any implementation which enables a piece of code written in one language to call functions written in another. As the name implies these implementations usually provide some interface; an abstraction describing for example a method signature; enabling one language to call a method in another language utilizing this interface. In practice FFI usually comes in terms of an Application Binary Interface (ABI) which describes a common standard for how to compile source code into machine code and shared library providing the common code both languages which to call. Two languages written in a difference source code but able to compile to some common ABI standard have interoperability. By far the most common ABI which many languages can compile to and by extension have interoperability with is the C ABI. The point at which some source language $A$ calls some target language $B$ is called the FFI boundary. Some examples of this boundary in different languages can be seen in the following.
\begin{lstlisting}[language=C]
    // mylib.c
    #include <stdio.h>

    void greet(const char* name) {
        printf("Hello, %s!\n", name);
    }
\end{lstlisting}

\begin{lstlisting}
    ccall((:greet, "mylib"), Cvoid, (Cstring,), "World")
\end{lstlisting}

\begin{lstlisting}
    #[link(name = "mylib")] 
    extern "C" { fn greet(name: *const c_char); }

    fn main() { 
        let name = "World"; 
        let c_name = CString::new(name).expect("CString::new failed"); 
        unsafe { 
            greet(c_name.as_ptr()); 
        } 
    }
\end{lstlisting}

\begin{lstlisting}
    mylib = ctypes.CDLL('./libmylib.so')

    mylib.greet.argtypes = [ctypes.c_char_p]  
    mylib.greet.restype = None                  

    name = b"World"  # Use bytes for C string
    mylib.greet(name)
\end{lstlisting}
One critical thing to observe is in all instance we must ensure the FFI boundary method and its arguments conform to the memory layout of the target language as specified by the ABI. Since string types for example generally have different underlying representations depending on the language here we must ensure the string has the form of a C-string, that is its a basic pointer to an array of characters `char*`.

This in turn limits FFI boundary methods by the syntax and underlying ABI of our target language. For example as C has no generics, thus we cannot utilize a generic method as an FFI boundary despite generics existing in our source language an Rust being compatible with the C ABI. 

\begin{lstlisting}
    extern "C" { 
        fn add<T>(a: T, b: T) -> T; 
    }
\end{lstlisting}
Stated differently FFI boundary method signatures must mirror those of the target language. We can create some flexibility here by abstracting the boundary utilizing wrappers; commonly macros; which make defining the boundary closer to that of the source language while implicitly ensuring that the actual underlying boundary is valid, an example of this is the `@ccall` macro in Julia.
\begin{lstlisting}
    @ccall library.function_name(argvalue1::argtype1, ...)::returntype
    @ccall function_name(argvalue1::argtype1, ...)::returntype
\end{lstlisting}

But this doesn't really address the underlying issue that our FFI boundary is limited by the target language. 

Application Binary Interface 

This is very much where the root of interoperability lies, and also its various issues. ABI stability is a key factor to understanding the current landscape of not only interoperability between languages but also within different versions of languages themselves. As the name implies the stability of an ABI refers to its specification, that being how a compiler generates machine code, being stable or unchanging. An ABI being "fully stable" implies that all aspects of its specifications will not change with any future modification of its execution system (JIT compiler, AOT compiler, etc.). One of the primary reasons for so many languages having interop with C is due to the fact that it has full ABI stability, thus there exist essentially a promise that a compiler can always generate the same machine code for a given source language that conforms to the defined C ABI standard knowing this will never some day break due to changes in C's calling conventions, memory layout, etc. 

The other side of this is ABI instability, most languages currently have what could be considered partial ABI stability. What this means in practice is that most languages have some execution system which generates machine code, commonly this version or a set of versions have a common ABI. Within this set of versions there exists stability, meaning shared library calls; which are reliant on ABI stability; can/could function with any other languages capable of producing machine code which conforms to this ABI. Though across different ABI's this communication breaks down as we no longer have a homogenous standard generating the machine code but conflicting and often incompatible standards. 

This nature of partial stability in the ABI's of most languages creates one of the primary limitations to language interoperability with FFI, due to the rather complex and to an extent controversial nature of having an ABI which is both fully specified and consistent across versions there quite simply are not alot of languages which have this and by extension not alot of compilers which chose to implement an ABI for this. Furthermore there is the point that if for some set of languages there is an existing C ABI already implemented, this in turn implies we have communication between these two languages with the common language taking the form of the C ABI. It should be clarified that while interop in many languages occurs with the C ABI as the basic common ground. 

C-ABI and Interop in practice

To describe how interop utilizing the C ABI actually plays out in practice lets express two arbitrary languages as $L_1$ and $L_2$ . In the case of primitives the generated machine code would naturally produce matching layouts, thus little additional work is involved beyond defining the FFI boundaries in both languages. As we start getting to more complex types we start wanting to pass more complex things across the FFI boundary that might not have as straightforward of a representation in C we run into the first issue with pure C ABI based interop. This being that it leads to considerable manual specification and redefining languages specific syntax, otherwise called marshalling or boxing through the FFI boundary and in turn unmarshalling in the target language. Additionally we must ensure that the representation of our type in $L_1$ matches that in $L_2$ which for a large library could mean having to manually specific all types such that we establish a mirrored relationship; while this is somewhat obvious that it has to happen the manual nature of it would be less then desirable in the case of very large libraries we wish to interop with.

To address these issues of having to manually box everything such that it is compatible with the C ABI various language features and libraries exist as abstractions to enable more seamless and simplified interop between languages. The common features with these interoperability abstraction systems are usually automatic type (code) generation through parsing and implicit boxing and unboxing of complex types that cant be trivially passed through the FFI boundary. Examples of this are Rusts CXX library or the way Swift implemented interop as a direct part of its compiler.

Through these abstractions interop between many languages has become a mostly trivial task, in that most of the manual activities are now generally automated in one way or another, though as stated before due to the fact that this is all ultimately still working through the C-ABI (or some slight modification of it) we are still very much limited in the things we can actually pass between languages. Though these limitations are generally not large enough to really discourage the usage of FFI as the primary means of interop. 

So to briefly summarize we can see that FFI generally relies on a common denominator ABI between languages; commonly the C ABI; and a set of tools to automate any manual boxing and unboxing such that the developer can - for the most part - simply define a boundary in both languages and use said boundary as if it were a regular call. An important final consideration with these FFI systems is how optimization works across language boundaries. Since the methods of shared libraries are only resolved at link time no optimizations except LTO can occur. The shared object file from the target language has optimizations applied from its own compiler then depending on if the compiler has Link Time Optimization (LTO) implemented we can optimize the whole program across the language boundary, otherwise no optimizations occurs across the language boundary.

WebAssembly (WASM)

WASM offers an interesting insights into how language interop is developing on the web. First announced in 2015 and then released in 2017 WASM is a byte-code format designed to be executed within web-browsers using stack-based Virtual Machines (VM) though has now also been implemented to run both via AOT and JIT compilers. The WASM specification was designed by the World Wide Web Consortium (W3C) but has various compiler implementations by different groups.  WASM when used as a compilation target for other languages not only allows potentially arbitrary languages to run on the web, but through its ABI also allows for another common denominator of communication. To understand the state of its ABI we have to examine the different compiler toolchains that target WASM. Currently the major ones are 

\begin{table*}[ht!]
\centering
\begin{tabular}{|l|p{15cm}|}
\hline
\textbf{Compiler/Toolchain} & \textbf{Description} \\ \hline
Emscripten & This was the first project to define a POSIX compliant ABI for WASM, though as of 2020 at least it is not stable. \\ \hline
Cheerp & Seem to support WASI-WASM as a target for the compiler. Inherently has interop with JS because it literally compiles to JS uses \href{https://github.com/leaningtech/ts2cpp/}{ts2cpp} for creating C++ interfaces from TS types. \\ \hline
WASI & A subgroup of the WASM community group which is aiming to define a set of APIs and a canonical WASM ABI, currently the actual implementation of this specification comes in the form of:
\begin{itemize}
    \item \href{https://github.com/wasienv/wasienv}{Wasienv} which can compile Swift and C++ to wasm conforming to the WASI standard.
    \item \href{https://github.com/WebAssembly/wasi-sdk}{wasi-sdk} which seems to be some more low level compiler for wasi, i think the like backend, so you just need to implement the frontend for specific languages.
    \item \href{https://wasmtime.dev/}{wasmtime} another wasm runtime which also has WASI as a target specification it seems.
    \item \href{https://github.com/singlestore-labs/wasix}{wasix} compatibility layer to make WASI POSIX compliant when built with the WASI SDK.
    \item \href{https://github.com/bytecodealliance/cargo-wasi}{wasm32-wasi} seems to be a frontend for Rust again using WASI.
\end{itemize}
WASI with the component model seems to have the most thoroughly documented ABI. \\ \hline
GoJS & Not much info on this, just seems that a \href{https://tinygo.org/}{go compiler} has wasm as a target. \\ \hline
\end{tabular}
\caption{Major WASM Compiler Toolchains and Their Descriptions}
\label{table:wasm_compilers}
\end{table*}

What we can understand from this is that it seems like WASI will likely be the ABI to which wasi-wasm will be the likely target most compilers aim to ultimately achieve, furthermore it seems WASI seems to aim for stability with its canonical ABI, which could suggest that we see a new common standard of interoperability, especially as wasm compilers evolve. One distinguishing factor of specifically WASI's canonical ABI is development of the **component model**, the component model refers to type definitions written in WASM Interface Type (WIT), which is a interface description language (IDL) used to express types in a language independent manner. From the defined WIT code we can generate the corresponding bindings in our language thus mitigating the need to any type-shenanigan's in the case of interop since our generated bindings will by default be compatible with the ABI with no issues. It should be noted that as the documentation specifies WIT implements contracts, that is similar to how an `extern` block expresses a function which must be ABI compatible so to do the generated bindings from the WIT code all inherently imply compatability with the underlying ABI. 

Thus if you have say some library compiled to wasi-wasm which utilizes the component model to specify the API you can in turn use the library specification to generate ABI compliant bindings for your source code, then use a wasi-wasm compiler and have full cross-language interoperability without the need for any complex wrapper libraries. Though once again here we are limited by the expressiveness of the component model and corresponding ABI, meaning that if a library wants to make something available for use externally it has to conform to the component model thus potentially limiting certain language specific features for a cross language setting. Unless similarly to the C ABI we adjust the compiler to support these language specific features and in turn break compatibility with the ABI. 