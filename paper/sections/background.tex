\section{Background}\label{s:background}


% \TODO{
% This section is optional. If needed, it provides the necessary context to help the reader understand the remainder of the thesis.
% }

Language interoperability; or interop for short; is broadly seen as the ability of two or more different programming languages to interact with each other and function as a part of a single system. A primary motivation behind the implementation of interop mechanics is the idea that while programming languages; especially modern ones; are often designed to be somewhat general-purpose, they are not necessarily the best tool for every job. The most established form of interop is the Foreign Function Interface (FFI), which often takes the form of a library written in the host language that allows it to call a function via a shared library written in the target language, commonly this being C or C++. 
\smallskip

\noindent \textbf{FFIs} in cases where there is little mismatch in the runtime and memory models of the host and guest language provides a generally effective means of interop. Though as the languages become more and more differen't we start to see an increase in the overhead with the main contributors to this generally being data marshalling and mismatched execution paradigms. Additionally a key drawback of FFIs are that they generally operate specifically between two languages, while in many cases this is sufficient or even intentional it lacks the flexibility of projects which wish to incorporate more languages. Recent developments in virtual machines especially ones which target ASTs have offered some interesting approaches to solving alot of the existing drawbacks of FFIs. 
\smallskip

\noindent \textbf{Meta-JIT Compilers} offer some very interesting insights into the future of language interop. In the last 20 or so years we have seen substantial developments in the creation of Meta-JIT compilers, which broadly speaking allow programmers to implement language interpreters, these interpreters are then combined with JIT compilers which either apply tracing; as in the case of RPython; or partial evaluation; as in the case of GraalVM. We can further divide these Meta-JIT compilers into ones which operate bytecode and ones that operate on ASTs. Whereas RPython can only operate on bytecode GraalVM can both operate on ASTs through its truffle language implementation framework and on bytecode through specifically its llvm language implementation, though at the cost of some optimization ability and interoperability. 

A key thing which is so revolutionary with Meta-JIT Compilers in the case of interop is that when combined with some language-agnostic communication interface like the Truffle OSM not only do you have a simple way of implementing a language and having it run on a highly optimized JIT compiler, but because we have everything essentially operating on the same runtime it massively simplifies alot of things that FFI has troubles with. Namely allows for effective language interop in a high performance context with close to no-boilerplate.

Though despite impressive implications the GraalVM has for language interoperability it still has some hurdles that hinder it from a larger scale adoption. One of the biggest ones being that while it does simplify a language implementation, there are substantial compatability limitations with existing infrastructure that will naturally occur. While it currently does support a relatively wide range of language implementations, which have even demonstrated improved performance over their traditional counterparts, it still lacks in compatability, clear developer documentation, and overall developer experience if a language implementation does not already exist.