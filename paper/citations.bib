@Conference{kiam_9689,
  author    = {{Klimov, A.V.}},
  booktitle = {Scientific service & Internet: proceedings of the 24th All-Russian Scientific Conference (September 19-22, 2022, online)},
  title     = {Supercompilation and partial evaluation are still not widely used in practice. Why and what to do?},
  year      = {2022},
  pages     = {312--331},
  publisher = {Keldysh Institute of Applied Mathematics},
  volume    = {24},
  abstract  = {Such methods of metacomputation as supercompilation and partial evaluation appeared around half a century ago. Since then, they have fruitfully developed, deep scientific results were achieved, many software prototypes were created. However, they are still not used in the practice of programming, although their authors foresaw a great prospect for them to automate programming and expected rapid achievement of the goals. What's the big deal? We consider the history of programming from the point of view of the evolutionary theory of metasystem transitions by V.F. Turchin in order to reveal the origins of metacomputation methods and their place in the overall picture. We note that unlike software tools that were easily put into practice, such as, for example, optimizing compilers, these methods could not be implemented in such a way that they could be used automatically, because they contain too many points of choice of solutions, options, degrees of freedom that the machine cannot resolve without human assistance. For further progress to practice, we propose to pay special attention to embedding metacomputation tools in modern programming environments and developing and designing convenient human-machine interfaces, where a person will remain the top-level metasystem that makes creative decisions. In addition, we propose to include supercomputers in the arsenal of software developers' tools, including metacomputation, as it happened in applied engineering fields, but for some reason the development of effective and reliable programs for critical applications is not considered to justify the use of supercomputers.},
  annote    = {Such methods of metacomputation as supercompilation and partial evaluation appeared around half a century ago. Since then, they have fruitfully developed, deep scientific results were achieved, many software prototypes were created. However, they are still not used in the practice of programming, although their authors foresaw a great prospect for them to automate programming and expected rapid achievement of the goals. What's the big deal? We consider the history of programming from the point of view of the evolutionary theory of metasystem transitions by V.F. Turchin in order to reveal the origins of metacomputation methods and their place in the overall picture. We note that unlike software tools that were easily put into practice, such as, for example, optimizing compilers, these methods could not be implemented in such a way that they could be used automatically, because they contain too many points of choice of solutions, options, degrees of freedom that the machine cannot resolve without human assistance. For further progress to practice, we propose to pay special attention to embedding metacomputation tools in modern programming environments and developing and designing convenient human-machine interfaces, where a person will remain the top-level metasystem that makes creative decisions. In addition, we propose to include supercomputers in the arsenal of software developers' tools, including metacomputation, as it happened in applied engineering fields, but for some reason the development of effective and reliable programs for critical applications is not considered to justify the use of supercomputers.},
  crossref  = {https://doi.org/10.20948/abrau-2022-38},
  doi       = {https://doi.org/10.20948/abrau-2022-38},
  eprint    = {https://keldysh.ru/abrau/2022/theses/38.pdf},
  type      = {Conference material},
  url       = {https://keldysh.ru/papers/2022/prep_vw.asp?pid=9689&lg=e},
}

@Article{Coquand1996,
  author    = {Coquand, Thierry},
  journal   = {Science of Computer Programming},
  title     = {An algorithm for type-checking dependent types},
  year      = {1996},
  issn      = {0167-6423},
  month     = may,
  number    = {1–3},
  pages     = {167-177},
  volume    = {26},
  doi       = {10.1016/0167-6423(95)00021-6},
  publisher = {Elsevier BV},
}

@Misc{Chung2023,
  author    = {Chung, Benjamin},
  title     = {{A Type System for Julia}},
  year      = {2023},
  copyright = {Creative Commons Attribution Share Alike 4.0 International},
  doi       = {10.48550/ARXIV.2310.16866},
  keywords  = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences},
  publisher = {arXiv},
}

@Book{pestov2024compiling,
  author = {Pestov, Slava},
  title  = {Compiling Swift Generics},
  year   = {2024},
  month  = aug,
  note   = {{Explains the generics implementation in the Swift compiler}},
}

@Article{Laird2022,
  author    = {Laird, James},
  title     = {Revisiting Decidable Bounded Quantification, via Dinaturality},
  year      = {2022},
  copyright = {Creative Commons Attribution 4.0 International},
  doi       = {10.48550/ARXIV.2212.04882},
  keywords  = {Logic in Computer Science (cs.LO), FOS: Computer and information sciences, FOS: Computer and information sciences, F.3.2},
  publisher = {arXiv},
}

@InProceedings{Pierce1992,
  author     = {Pierce, Benjamin C.},
  booktitle  = {Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL ’92},
  title      = {Bounded quantification is undecidable},
  year       = {1992},
  pages      = {305--315},
  publisher  = {ACM Press},
  series     = {POPL ’92},
  collection = {POPL ’92},
  doi        = {10.1145/143165.143228},
}

@Misc{hu_cartesian_2018,
  author      = {Nick Hu},
  month       = {Trinity term},
  note        = {Third Year Project, supervised by Professor Luke Ong},
  title       = {Cartesian Closed Categories and the Simply-Typed λ-Calculus},
  year        = {2018},
  address     = {Oxford, United Kingdom},
  institution = {St. Catherine’s College, University of Oxford},
  school      = {University of Oxford},
  type        = {Bachelor's thesis},
}

@Book{1999,
  publisher = {Springer Berlin Heidelberg},
  title     = {Partial Evaluation},
  year      = {1999},
  isbn      = {9783540470182},
  doi       = {10.1007/3-540-47018-2},
  issn      = {1611-3349},
  journal   = {Lecture Notes in Computer Science},
}

@Misc{Veldhuizen1998,
  author    = {Veldhuizen, Todd L.},
  title     = {C++ Templates as Partial Evaluation},
  year      = {1998},
  copyright = {Assumed arXiv.org perpetual, non-exclusive license to distribute this article for submissions made before January 2004},
  doi       = {10.48550/ARXIV.CS/9810010},
  keywords  = {Programming Languages (cs.PL), Performance (cs.PF), FOS: Computer and information sciences, FOS: Computer and information sciences, F.3.2; D.3.3; D.3.4},
  publisher = {arXiv},
}

@InBook{Henglein1991,
  author    = {Henglein, Fritz},
  pages     = {448--472},
  publisher = {Springer Berlin Heidelberg},
  title     = {Efficient type inference for higher-order binding-time analysis},
  year      = {1991},
  isbn      = {9783540475996},
  booktitle = {Functional Programming Languages and Computer Architecture},
  doi       = {10.1007/3540543961_22},
  issn      = {1611-3349},
}

@Book{JacobsCLTT,
  author    = {B. Jacobs},
  publisher = {North Holland},
  title     = {Categorical Logic and Type Theory},
  year      = {1999},
  address   = {Amsterdam},
  number    = {141},
  series    = {Studies in Logic and the Foundations of Mathematics},
}

@Article{imada_equivalence_2019,
  author  = {Kei Imada},
  journal = {Unpublished manuscript},
  title   = {The Equivalence of Typed λ Calculi and Cartesian Closed Categories},
  year    = {2019},
  month   = {January},
}

@InBook{Csoernyei,
  author    = {Csörnyei, Zoltán and Dévai, Gergely},
  pages     = {87--111},
  publisher = {Springer Berlin Heidelberg},
  title     = {An Introduction to the Lambda Calculus},
  year      = {2010},
  isbn      = {9783540880592},
  booktitle = {Central European Functional Programming School},
  doi       = {10.1007/978-3-540-88059-2_3},
  issn      = {1611-3349},
}

@Misc{cs4110-lecture19,
  author       = {{CS 4110 - Programming Languages and Logics}},
  howpublished = {{https://www.cs.cornell.edu/courses/cs4110/2014fa/lectures/lecture19.pdf}},
  note         = {Lecture notes for CS 4110 - Programming Languages and Logics, Cornell University},
  title        = {{Lecture \#19: Simply Typed λ-calculus}},
  year         = {2023},
  institution  = {Cornell University},
}

@Article{10.1145/5956.5957,
  author     = {Turchin, Valentin F.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  title      = {The concept of a supercompiler},
  year       = {1986},
  issn       = {0164-0925},
  month      = jun,
  number     = {3},
  pages      = {292–325},
  volume     = {8},
  abstract   = {A supercompiler is a program transformer of a certain type. It traces the possible generalized histories of computation by the original program, and compiles an equivalent program, reducing in the process the redundancy that could be present in the original program. The nature of the redundancy that can be eliminated by supercompilation may be various, e.g., some variables might have predefined values (as in partial evaluation), or the structure of control transfer could be made more efficient (as in lazy evaluation), or it could simply be the fact that the same variable is used more than once. The general principles of supercompilation are described and compared with the usual approach to program transformation as a stepwise application of a number of equivalence rules. It is argued that the language Refal serves the needs of supercompilation best. Refal is formally defined and compared with Prolog and other languages. Examples are given of the operation of a Refal supercompiler implemented at CCNY on an IBM/370.},
  address    = {New York, NY, USA},
  doi        = {10.1145/5956.5957},
  issue_date = {July 1986},
  numpages   = {34},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/5956.5957},
}

@InProceedings{Bolingbroke2010,
  author    = {Bolingbroke, Maximilian and Peyton Jones, Simon},
  booktitle = {Proceedings of the Third ACM Haskell Symposium on Haskell},
  title     = {Supercompilation by evaluation},
  year      = {2010},
  address   = {New York, NY, USA},
  pages     = {135–146},
  publisher = {Association for Computing Machinery},
  series    = {Haskell '10},
  abstract  = {This paper shows how call-by-need supercompilation can be recast to be based explicitly on an evaluator, contrasting with standard presentations which are specified as algorithms that mix evaluation rules with reductions that are unique to supercompilation. Building on standard operational-semantics technology for call-by-need languages, we show how to extend the supercompilation algorithm to deal with recursive let expressions.},
  doi       = {10.1145/1863523.1863540},
  isbn      = {9781450302524},
  keywords  = {deforestation, haskell, optimisation, specialisation, supercompilation},
  location  = {Baltimore, Maryland, USA},
  numpages  = {12},
  url       = {https://doi.org/10.1145/1863523.1863540},
}

@InBook{Harmelen1989,
  author    = {van Harmelen, Frank},
  pages     = {169--187},
  publisher = {Springer Berlin Heidelberg},
  title     = {The limitations of partial evaluation},
  isbn      = {9783540482031},
  booktitle = {Machines, Languages, and Complexity},
  date      = {1989},
  doi       = {10.1007/bfb0015938},
  issn      = {1611-3349},
}

@InProceedings{10.1145/3062341.3062381,
  author    = {W\"{u}rthinger, Thomas and Wimmer, Christian and Humer, Christian and W\"{o}\ss{}, Andreas and Stadler, Lukas and Seaton, Chris and Duboscq, Gilles and Simon, Doug and Grimmer, Matthias},
  booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  title     = {Practical partial evaluation for high-performance dynamic language runtimes},
  year      = {2017},
  address   = {New York, NY, USA},
  pages     = {662–676},
  publisher = {Association for Computing Machinery},
  series    = {PLDI 2017},
  abstract  = {Most high-performance dynamic language virtual machines duplicate language semantics in the interpreter, compiler, and runtime system. This violates the principle to not repeat yourself. In contrast, we define languages solely by writing an interpreter. The interpreter performs specializations, e.g., augments the interpreted program with type information and profiling information. Compiled code is derived automatically using partial evaluation while incorporating these specializations. This makes partial evaluation practical in the context of dynamic languages: It reduces the size of the compiled code while still compiling all parts of an operation that are relevant for a particular program. When a speculation fails, execution transfers back to the interpreter, the program re-specializes in the interpreter, and later partial evaluation again transforms the new state of the interpreter to compiled code. We evaluate our approach by comparing our implementations of JavaScript, Ruby, and R with best-in-class specialized production implementations. Our general-purpose compilation system is competitive with production systems even when they have been heavily optimized for the one language they support. For our set of benchmarks, our speedup relative to the V8 JavaScript VM is 0.83x, relative to JRuby is 3.8x, and relative to GNU R is 5x.},
  doi       = {10.1145/3062341.3062381},
  isbn      = {9781450349888},
  keywords  = {virtual machine, partial evaluation, optimization, language implementation, dynamic languages},
  location  = {Barcelona, Spain},
  numpages  = {15},
  url       = {https://doi.org/10.1145/3062341.3062381},
}

@InBook{Futamura1983,
  author    = {Futamura, Yoshihiko},
  pages     = {1--35},
  publisher = {Springer Berlin Heidelberg},
  title     = {Partial computation of programs},
  year      = {1983},
  isbn      = {9783540394426},
  booktitle = {RIMS Symposia on Software Science and Engineering},
  doi       = {10.1007/3-540-11980-9_13},
  issn      = {1611-3349},
}

@Article{Barrett2015,
  author    = {Barrett, Edd and Bolz, Carl Friedrich and Tratt, Laurence},
  journal   = {{Computer Languages, Systems &; Structures}},
  title     = {Approaches to interpreter composition},
  year      = {2015},
  issn      = {1477-8424},
  month     = dec,
  pages     = {199--217},
  volume    = {44},
  doi       = {10.1016/j.cl.2015.03.001},
  publisher = {Elsevier BV},
}

@Article{SANG2002175,
  author   = {Janche Sang and Gregory Follen and Chan Kim and Isaac Lopez},
  journal  = {Information and Software Technology},
  title    = {Development of CORBA-based engineering applications from legacy Fortran programs},
  year     = {2002},
  issn     = {0950-5849},
  number   = {3},
  pages    = {175-184},
  volume   = {44},
  abstract = {A majority of scientific and engineering applications in aerodynamics and solid mechanics are written in Fortran. To reduce the high cost of software development, NASA researchers reuse most of the legacy Fortran codes instead of developing them from scratch in the numerical propulsion system simulation project. In this paper, we present an efficient methodology for integrating legacy applications written in Fortran into a distributed object framework. Issues and strategies regarding the conversion and wrapping of Fortran codes into common object request broker architecture objects are discussed. Fortran codes are modified as little as possible when they are decomposed into modules and wrapped as objects. We implement a wrapper generator which takes the Fortran application as input and generates the C++ wrapper files and interface definition language file. Tedious programming tasks for wrapping the codes can therefore be reduced.},
  doi      = {https://doi.org/10.1016/S0950-5849(02)00005-8},
  keywords = {Code wrapping, CORBA, Distributed object, Fortran, Legacy software, Software reuse},
  url      = {https://www.sciencedirect.com/science/article/pii/S0950584902000058},
}

@InProceedings{SleeThriftS,
  author = {Mark Slee and Aditya Agarwal and Marc Kwiatkowski},
  title  = {Thrift : Scalable Cross-Language Services Implementation},
  year   = {2007},
  url    = {https://api.semanticscholar.org/CorpusID:14349304},
}

@InProceedings{10.1145/1869459.1869517,
  author    = {Bebenita, Michael and Brandner, Florian and Fahndrich, Manuel and Logozzo, Francesco and Schulte, Wolfram and Tillmann, Nikolai and Venter, Herman},
  booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
  title     = {SPUR: a trace-based JIT compiler for CIL},
  year      = {2010},
  address   = {New York, NY, USA},
  pages     = {708–725},
  publisher = {Association for Computing Machinery},
  series    = {OOPSLA '10},
  abstract  = {Tracing just-in-time compilers (TJITs) determine frequently executed traces (hot paths and loops) in running programs and focus their optimization effort by emitting optimized machine code specialized to these traces. Prior work has established this strategy to be especially beneficial for dynamic languages such as JavaScript, where the TJIT interfaces with the interpreter and produces machine code from the JavaScript trace.This direct coupling with a JavaScript interpreter makes it difficult to harness the power of a TJIT for other components that are not written in JavaScript, e.g., the DOM implementation or the layout engine inside a browser. Furthermore, if a TJIT is tied to a particular high-level language interpreter, it is difficult to reuse it for other input languages as the optimizations are likely targeted at specific idioms of the source language.To address these issues, we designed and implemented a TJIT for Microsoft's Common Intermediate Language CIL (the target language of C#, VisualBasic, F#, and many other languages). Working on CIL enables TJIT optimizations for any program compiled to this platform. In addition, to validate that the performance gains of a TJIT for JavaScript do not depend on specific idioms of JavaScript that are lost in the translation to CIL, we provide a performance evaluation of our JavaScript runtime which translates JavaScript to CIL and then runs on top of our CIL TJIT.},
  doi       = {10.1145/1869459.1869517},
  isbn      = {9781450302036},
  keywords  = {cil, dynamic compilation, javascript, just-in-time, tracing},
  location  = {Reno/Tahoe, Nevada, USA},
  numpages  = {18},
  url       = {https://doi.org/10.1145/1869459.1869517},
}

@InProceedings{Rigger2016SulongM,
  author = {Manuel Rigger},
  title  = {{Sulong : Memory Safe and Efficient Execution of LLVM-Based Languages}},
  year   = {2016},
  url    = {https://api.semanticscholar.org/CorpusID:38362945},
}

@InProceedings{10.5555/646149.679193,
  author    = {H\"{o}lzle, Urs and Chambers, Craig and Ungar, David},
  booktitle = {Proceedings of the European Conference on Object-Oriented Programming},
  title     = {{Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches}},
  pages     = {21–38},
  publisher = {Springer-Verlag},
  series    = {ECOOP '91},
  date      = {1991},
  isbn      = {3540542620},
  location  = {Berlin, Heidelberg},
  numpages  = {18},
}

@InProceedings{10.1145/1297081.1297091,
  author    = {Ancona, Davide and Ancona, Massimo and Cuni, Antonio and Matsakis, Nicholas D.},
  booktitle = {Proceedings of the 2007 Symposium on Dynamic Languages},
  title     = {{RPython: a step towards reconciling dynamically and statically typed OO languages}},
  year      = {2007},
  address   = {New York, NY, USA},
  pages     = {53–64},
  publisher = {Association for Computing Machinery},
  series    = {DLS '07},
  abstract  = {Although the C-based interpreter of Python is reasonably fast, implementations on the CLI or the JVM platforms offers some advantages in terms of robustness and interoperability. Unfortunately, because the CLI and JVM are primarily designed to execute statically typed, object-oriented languages, most dynamic language implementations cannot use the native bytecodes for common operations like method calls and exception handling; as a result, they are not able to take full advantage of the power offered by the CLI and JVM.We describe a different approach that attempts to preserve the flexibility of Python, while still allowing for efficient execution. This is achieved by limiting the use of the more dynamic features of Python to an initial, bootstrapping phase. This phase is used to construct a final RPython (Restricted Python) program that is actually executed. RPython is a proper subset of Python, is statically typed, and does not allow dynamic modification of class or method definitions; however, it can still take advantage of Python features such as mixins and first-class methods and classes.This paper presents an overview of RPython, including its design and its translation to both CLI and JVM bytecode. We show how the bootstrapping phase can be used to implement advanced features, like extensible classes and generative programming. We also discuss what work remains before RPython is truly ready for general use, and compare the performance of RPython with that of other approaches.},
  doi       = {10.1145/1297081.1297091},
  isbn      = {9781595938688},
  keywords  = {Python, JVM, .NET},
  location  = {Montreal, Quebec, Canada},
  numpages  = {12},
  url       = {https://doi.org/10.1145/1297081.1297091},
}

@InProceedings{Woess2014,
  author     = {Wöß, Andreas and Wirth, Christian and Bonetta, Daniele and Seaton, Chris and Humer, Christian and Mössenböck, Hanspeter},
  booktitle  = {Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools},
  title      = {An object storage model for the truffle language implementation framework},
  year       = {2014},
  month      = sep,
  pages      = {133--144},
  publisher  = {ACM},
  series     = {PPPJ ’14},
  collection = {PPPJ ’14},
  doi        = {10.1145/2647508.2647517},
}

@Article{Bolz2015,
  author    = {Bolz, Carl Friedrich and Tratt, Laurence},
  journal   = {Science of Computer Programming},
  title     = {{The impact of meta-tracing on VM design and implementation}},
  year      = {2015},
  issn      = {0167-6423},
  month     = feb,
  pages     = {408--421},
  volume    = {98},
  doi       = {10.1016/j.scico.2013.02.001},
  publisher = {Elsevier BV},
}

@InProceedings{Marr2015,
  author     = {Marr, Stefan and Ducasse, Stéphane},
  booktitle  = {Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  title      = {Tracing vs. partial evaluation: comparing meta-compilation approaches for self-optimizing interpreters},
  year       = {2015},
  month      = oct,
  pages      = {821--839},
  publisher  = {ACM},
  series     = {SPLASH ’15},
  collection = {SPLASH ’15},
  doi        = {10.1145/2814270.2814275},
}

@InBook{Awodey2015,
  author    = {Awodey, Steve},
  pages     = {1--10},
  publisher = {Springer Berlin Heidelberg},
  title     = {Homotopy Type Theory},
  year      = {2015},
  isbn      = {9783662458242},
  booktitle = {Logic and Its Applications},
  doi       = {10.1007/978-3-662-45824-2_1},
  issn      = {1611-3349},
}

@Article{Palsberg1992,
  author    = {Palsberg, Jens and Schwartzbach, Michael I.},
  journal   = {DAIMI Report Series},
  title     = {Binding Time Analysis: Abstract Interpretation vs. Type Inference},
  year      = {1992},
  issn      = {0105-8517},
  month     = apr,
  number    = {393},
  volume    = {21},
  doi       = {10.7146/dpb.v21i393.6628},
  publisher = {Det Kgl. Bibliotek/Royal Danish Library},
}

@InProceedings{Affeldt2019,
  author      = {Reynald Affeldt and Jacques Garrigue and Xuanrui Qi and Kazunari Tanaka},
  booktitle   = {Proceedings of the Coq Workshop 2019},
  title       = {Type-Driven Development of Certified Tree Algorithms: An Experience Report on Dependently-Typed Programming in Coq},
  year        = {2019},
  address     = {Portland, Oregon, USA},
  month       = sep,
  institution = {National Institute of Advanced Industrial Science and Technology, Japan and Graduate School of Mathematics, Nagoya University, Japan and Department of Computer Science, Tufts University, USA and Inria Paris, France},
}

@Book{Okasaki1998,
  author    = {Okasaki, Chris},
  publisher = {Cambridge University Press},
  title     = {Purely Functional Data Structures},
  year      = {1998},
  isbn      = {9780511530104},
  month     = apr,
  doi       = {10.1017/cbo9780511530104},
}

@Book{10.5555/2584504,
  author    = {Chlipala, Adam},
  publisher = {The MIT Press},
  title     = {Certified Programming with Dependent Types: A Pragmatic Introduction to the Coq Proof Assistant},
  year      = {2013},
  isbn      = {0262026651},
  abstract  = {The technology of mechanized program verification can play a supporting role in many kinds of research projects in computer science, and related tools for formal proof-checking are seeing increasing adoption in mathematics and engineering. This book provides an introduction to the Coq software for writing and checking mathematical proofs. It takes a practical engineering focus throughout, emphasizing techniques that will help users to build, understand, and maintain large Coq developments and minimize the cost of code change over time. Two topics, rarely discussed elsewhere, are covered in detail: effective dependently typed programming (making productive use of a feature at the heart of the Coq system) and construction of domain-specific proof tactics. Almost every subject covered is also relevant to interactive computer theorem proving in general, not just program verification, demonstrated through examples of verified programs applied in many different sorts of formalizations. The book develops a unique automated proof style and applies it throughout; even experienced Coq users may benefit from reading about basic Coq concepts from this novel perspective. The book also offers a library of tactics, or programs that find proofs, designed for use with examples in the book. Readers will acquire the necessary skills to reimplement these tactics in other settings by the end of the book. All of the code appearing in the book is freely available online.},
}

@Article{Aschieri2019,
  author    = {Aschieri, Federico and Genco, Francesco A.},
  journal   = {Proceedings of the ACM on Programming Languages},
  title     = {Par means parallel: multiplicative linear logic proofs as concurrent functional programs},
  year      = {2019},
  issn      = {2475-1421},
  month     = dec,
  number    = {POPL},
  pages     = {1--28},
  volume    = {4},
  doi       = {10.1145/3371086},
  publisher = {Association for Computing Machinery (ACM)},
}

@Comment{jabref-meta: databaseType:bibtex;}
