{
	"nodes":[
		{"id":"a71ac2ce881e1703","type":"text","text":"### move semantics theory\n- destructive move - (a la Rust) :\n\t- we move the memory to a new address  \n\t\t- e.g. String we have a consistent heap location but we essentially invalidate the string wrapper type when we move it to a function\n\t- we drop the old address (make it invalid to use)\n- copying move - (a la C++)\n\t- we create a new object at a new memory location \n\t- implemented via the constructor \n\t- moved from value destructor is run once scope ends\n- non-destructive move (constructor) - (C++ feature)\n\t- in essence a destructive move \n\t- \"`std::move` docs\": indicates object may be moved from... transfer of resources from `t` to another object\n- copy (constructor) / clone  (default/implicit is shallow)\n\t- creates an object as a copy of some target object (implicit allocation)\n\t- either implicit if a compiler generates it or user-defined\n\t- C++ - only copies data members it knows about (AKA nothing from derived objects)\n\t- Rust - clone (explicit copy) , copy (implicit copy)\n\t\t- Clone - explicit call of how to copy the data \n\t\t\t- Can either mark objects with it or provide custom impl.\n\t\t- Copy - implicit implementation, cannot uniquely implement\n\t\t\t- No available custom impl possible\n- smart pointers (reference count based mechanisms)\n\t- `shared_ptr` manages shared ownership of an object,\n\t\t- multiple pointers to manage the same resource \n\t- `unique_ptr` exclusive ownership, moves allowed but no copies\n\t- Note : Since C++ still must call destructors on moved-from objects the only thing it does to them is nullify the data their are holding, this in turn leads to us having usable null pointers after ownership transfer AKA nullable smart pointers \n\t\t- Issue : cant distinguish between a moved-from ptr object and a standard nullptr since they are inherently the same\n\t- `weak_ptr` subtype of `shared_ptr` but dont increment reference count \n\t\t- useful in cyclic datastructures where just `shared_ptr` would lead to a memory leak\n\t- `make_shared/unique` creates smart pointers in the same memory space as the managed object \n\t\t- `shared` typically only preforms on allocation for `<T>`\n\t\t- `unqiue` does not (but is proposed to be implemented [here](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0211r3.html)\n- address passing \n\t- just passing the pointer to the memory then dereferencing \n- reference passing \n\t- passing a reference type, any changes in the scope of the function reflected in calle \n- call by sharing \n\t- mix between copy and reference passing, boxed types are typically references whereas primitives are copied","x":-980,"y":-720,"width":800,"height":1300},
		{"id":"c68ea8b71e23fbf3","type":"text","text":"### Data structures\nBasic data container \n- JS Objects - JIT Compilation (V8 mainly) prototype-based\n\t- [explainer](https://v8.dev/blog/fast-properties)\n\t- Every object on the V8 heap managed by the GC has its first field point to a HiddenClass which contains meta information\n\t- So the idea is that we use the HiddenClass to determine if a specific property access is valid, so a run-time check it seems \n- Python Classes - Compiled, Interpreted, JIT compiled\n\t- [explainer](https://docs.python.org/3/reference/datamodel.html)\n- Java Classes - JIT Compiled (JVM)\n\t- asdasdasd\n- C++ Class - Compiled\n\t- VTables\n- C Struct - Compiled\n\t- Nothing\n- C# Struct - JIT Compiled Common Language Runtime (Intermediate Language)\n\t- Reflection\n- PHP Class - Interpreted\n\t- ??\n- Go Structs - Compiled\n- Rust Structs - Compiled \n- Kotlin class - JIT Compiled\n- Lua tables (associative arrays with named indicies) - Interpreted\n- Dart class - Compiled \n- Ruby Struct - Interpreted \n- Swift Struct - Compiled\n- Scala Classes - JIT Compiled (JVM)","x":-40,"y":-760,"width":720,"height":920},
		{"id":"8da9bb5c9233cfd0","type":"text","text":"### Popular general purpose languages\n- JavaScript \n- Python \n- Java\n- C# \n- C++ \n- C \n- PHP \n- Go \n- Rust \n- Kotlin \n- Lua \n- Dart \n- Ruby \n- Swift \n- Scala","x":760,"y":-720,"width":480,"height":500},
		{"id":"86a04e76a07d2266","type":"text","text":"### swift compiler architecture \n[docs](https://www.swift.org/documentation/swift-compiler/)\n- parsing \n- semantic analysis of AST \n- clang importer which maps c/objective-c/c++ apis to corresponding swift apis \n- swift intermediate language (SIL) generation \n\t- SIL guaranteed transformations\n\t- so we are making sure shit is correct \n\t- SIL optimizations \n\t- just even more optimizations apparently \n- LLVM IR generation \n\t- even more LLVM IR optimizations ","x":1672,"y":1000,"width":576,"height":466},
		{"id":"daf38ad7f5daa3a6","type":"text","text":"### module map exampel \n```\nmodule std [system] [extern_c] {\n  module assert {\n    textual header \"assert.h\"\n    header \"bits/assert-decls.h\"\n    export *\n  }\n\n  module complex {\n    header \"complex.h\"\n    export *\n  }\n\n  module ctype {\n    header \"ctype.h\"\n    export *\n  }\n\n  module errno {\n    header \"errno.h\"\n    header \"sys/errno.h\"\n    export *\n  }\n\n  module fenv {\n    header \"fenv.h\"\n    export *\n  }\n\n  // ...more headers follow...\n}\n```","x":1520,"y":-220,"width":638,"height":904},
		{"id":"4bbc30729a19af75","type":"text","text":"### Binding generation tools\n- C++ <-> Rust\n\t- [Crubit](https://github.com/google/crubit)\n\t\t- parses header\n\t\t- generates an quasi-IR which can be serialized to JSON and then parsed on the rust side to generate headers \n\t- [autocxx](https://google.github.io/autocxx/)\n\t- [cbindgen](https://github.com/mozilla/cbindgen)\n\t- [cxx](https://cxx.rs/)\n\t- [bindgen](https://rust-lang.github.io/rust-bindgen/)\n\t- [diplomat](https://github.com/rust-diplomat/diplomat)\n- C++ <-> Swift\n\t- Swift compiler embeds clang, utilizes clang `modules` \n\t\t- imports C++ headers using clang modules\n\t\t- needs `module.modulemap` to describe how c++ headers map to clang module \n\t- uses the swift compiler for interop\n\t- uses c++ types and calls C++ functions directly without any indirection or wrapping\n\t- c++ structures and classes mapped to value types AKA always copied\n\t\t- swift uses c++ copy constructor and destructor\n\t- internally it \n\t\t- parses C++ header\n\t\t- converts it to an AST \n\t\t- from this AST gets the swift AST \n\t\t- swift emits LLVM IR for swift code \n\t\t- swift tells clang to emit llvm IR for C++ code\n\t\t- llvm emits machine code for both\n\t- Cannot deal with templates or with inheritance\n- C++ <-> Python \n\t- [pybind11](https://github.com/pybind/pybind11) (based on Boost.python)\n\t- [cppyy](https://cppyy.readthedocs.io/en/latest/) \n\t\t- run-time Python-C++ binding generator \n\t\t- based on C++ interpreter [cling](https://github.com/vgvassilev/cling)\n\t- [Cython](https://cython.org/)\n\t\t- optimizing static compiler for both python and extended cython programming language based on pyrex\n\t\t- can generate efficient c code from cython code; c code is generated once then compiles with c/c++ compilers in \n\t- [codon](https://docs.exaloop.io/codon/interoperability/cpp)\n\t\t- high performance AOT compiler\n\t\t- only supports top level non-generic functions\n- C++ <-> Julia \n\t- Jluna \n\t- CxxWrap (based on Boost.python)\n\t- Cxx.jl \n- C++ <-> Java \n\t- [javacpp](https://github.com/bytedeco/javacpp/wiki)\n\t\t- seems to work similar to other methods in that it does header parsing -> target code generation -> compilation\n\t\t- is an abstraction on top of the Java Native Interface (JNI)\n\t\t- seems to be able to do some type of run time machine code generation as we can manually instantiate templates with annotations\n\t\t- want to use clang for the parsing phase\n- C <-> Python \n\t- [cffi](https://github.com/python-cffi/cffi)\n\t- [ctypes](https://docs.python.org/3/library/ctypes.html)\n\t- all the compilers seemingly \n\t","x":320,"y":320,"width":860,"height":1560},
		{"id":"6df00c6b2b5e630c","type":"text","text":"### lifetime models \n- C++ : https://en.cppreference.com/w/cpp/language/lifetime\n\t- uses Resource acquisition and initalization (RAII)\n- Rust : https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html also uses RAII\n- Swift : uses Automatic Reference Counting \n","x":-740,"y":720,"width":750,"height":670}
	],
	"edges":[
		{"id":"7c4e04c19e7c196d","fromNode":"daf38ad7f5daa3a6","fromSide":"left","toNode":"4bbc30729a19af75","toSide":"right"},
		{"id":"40d5a771eb55be36","fromNode":"86a04e76a07d2266","fromSide":"left","toNode":"4bbc30729a19af75","toSide":"right"}
	]
}